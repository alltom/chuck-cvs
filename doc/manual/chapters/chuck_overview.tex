\chapter{Overview}



ChucK is a strongly-typed, strongly-timed, concurrent audio and multimedia programming language. It is compiled into virtual instructions, which is immediately run in the ChucK Virtual Machine. This guide documents the features of the Language, Compiler, and Virtual Machine for a ChucK programmer.
 
\section{running ChucK}

Some quick notes:
\begin{chuckitemize}
\item you can install ChucK (see build instructions) or run it from a local directory.
\item ChucK is a command line application called chuck. (also see the Audicle)
\item use command line prompt/terminal to run ChucK: (e.g. Terminal or xterm on OS X, cmd or cygwin on Windows, on Linux, you surely have your preferred terminal.)
\item this is a quick overview, see VM options for a more complete guide to command line options.
\end{chuckitemize}
To run ChucK with a program/patch called foo.ck simply run chuck and then the name of the file:
\chuckterm{ \prompt chuck foo.ck }

To run ChucK with multiple patches concurrently (or the same one multiple times):
\chuckterm{ \prompt chuck foo.ck bar.ck bar.ck boo.ck }

There are several flags you can specify to control how ChucK operates, or to find out about the system. For example,the following probes the audio system and prints out all available audio devices and MIDI devices. You may then refer to them (by number usually) from the command line or from your program. (again, see VM Options for a complete list)
\chuckterm{ \prompt chuck \doubledash probe }

ChucK can be run in a different terminal as a host/listener that patches may be sent to. The server should invoke the --loop flag to specify that the virtual machine should not halt automatically (when the current programs exit).
\chuckterm{ \prompt chuck \doubledash loop }

(See the guide to On-the-fly Programming for more information)

If a ChucK listener is running, we can (from a second terminal) send a program/patch to to the listener by using the + command line option:
\chuckterm{ \prompt chuck + foo.ck }

Similarly, you can use - and = to remove/replace a patch in the listener, and use \^ to find out the status. Again, see On-the-fly Programming for more information.

To run most of the code or examples in this language specification, you only need to use the basic chuck program.
 

\section{comments}

Comments are sections of code that are ignored by a compiler. These help other programmers (and yourself) interpret your code. Double slashes indicate to the compiler to skip the rest of the line. For now, there is  no block commenting.
\begin{verbatim}
    // this is a comment
    int foo; // another comment
\end{verbatim}
 

\section{debug print}

For the time being, stdout and chout have been temporarily disabled for the present release. In their place we have provided a debug print syntax:
\begin{verbatim}
    // prints out value of expression
    <<< expression >>>;
\end{verbatim}

This will print the values and types of any expressions placed within them. This debug print construction may be placed around any non-declaration expression ( non l-value ) and will not affect the execution of the code. Expressions which represent an object will print the value of that object's reference address:
\begin{verbatim}
    // assign 5 to a newly declared variable
    5 => int i;
    // prints "5 : (int)"
    <<<i>>>;

    // prints "hello! : (string)"
    <<<"hello!">>>; //prints "hello! : (string)"

    // prints "3.5 : (float)"
    <<<1.0 + 2.5 >>>=> float x;
\end{verbatim}

For more formatted data output, a comma-separated list of expressions will print only their respective values (with one space between):
\begin{verbatim}
    // prints "the value of x is 3.5" (x from above)
    <<<"the value of x is" , x >>>;

    // prints "4 + 5 is 9"
    <<<"4 + 5 is", 4 + 5>>>;

    // prints "here are 3 random numbers ? ? ?"
    <<<"here are 3 random numbers", 
        std.rand2(0,9), 
        std.rand2(0,9),
        std.rand2(0,9) >>>; 
\end{verbatim}
 

\section{reserved words}
(primitive types) 
\begin{chuckitemize}
\item int 
\item float 
\item time 
\item dur 
\item void 
\item same (unimplemented) 
\end{chuckitemize}
(control structures) 
\begin{chuckitemize}
\item if 
\item else 
\item while 
\item until 
\item for 
\item break 
\item continue 
\item return 
\item switch (unimplemented) 
\end{chuckitemize}
(class keywords) 
\begin{chuckitemize}
\item class 
\item extends 
\item public 
\item static 
\item pure 
\item this 
\item super (unimplemented) 
\item interface (unimplemented) 
\item implements (unimplemented) 
\item protected (unimplemented) 
\item private (unimplemented) 
\end{chuckitemize}
(other chuck keywords)
\begin{chuckitemize} 
\item function 
\item fun 
\item spork 
\item const 
\item new 
\end{chuckitemize}
(special values) 
\begin{chuckitemize}
\item now 
\item true 
\item false 
\item maybe 
\item null 
\item NULL 
\item me 
\item pi 
\end{chuckitemize}
(special : default durations) 
\begin{chuckitemize}
\item samp 
\item ms 
\item second 
\item minute 
\item hour 
\item day 
\item week 
\end{chuckitemize}
(special : global ugens) 
\begin{chuckitemize}
\item dac 
\item adc 
\item blackhole
\end{chuckitemize}

(operators)
\begin{chuckitemize}
\item +
\item -
\item *
\item /
\item \%
\item \chuckop
\item =\textless
\item \textbar \textbar
\item \&\&
\item ==
\item $\wedge$
\item \&
\item \textbar
\item \textasciitilde
\item ::
\item ++
\item --\,-- 
\item \textgreater
\item \textless
\item @=\textgreater
\item +=\textgreater
\item -=\textgreater
\item *=\textgreater
\item /=\textgreater
\item \%=\textgreater
\end{chuckitemize}

(reserved)
\begin{chuckitemize}
\item then
\item before
\item after
\item at
\end{chuckitemize}