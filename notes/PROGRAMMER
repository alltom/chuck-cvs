---
ChucK Programmers's Guide

chuck home: http://chuck.cs.princeton.edu/
current version of this document: http://chuck.cs.princeton.edu/doc/program/

---

related: the ChucK Tutorial | Developer's Guide | ChucK Home

Introduction:

If this is your first time programming ChucK, it might be useful to read the ChucK Tutorial 
(QUICKSTART).

 ---

Overview:

ChucK is a strongly-typed, 'strongly-timed', concurrent audio and multimedia programming language.  It is 
compiled into virtual instructions, which is immediately run in the ChucK Virtual Machine.  This guide documents 
the features of the Language, Compiler, and Virtual Machine for a ChucK programmer.  If you like to help develop 
ChucK (contribute to the project), visit the developer page (DEVELOPER).

---

The ChucK Compiler + Virtual Machine

Let's start with the compiler/virtual machine, both of which runs in the same process.  By now, you should have 
built/installed ChucK (BUILD), and perhaps taken the tutorial (QUICKSTART).  This guide is intended to be more 
complete and referential than the tutorial.

(NOTE to OS X Users): we are experiencing occasional audio interruptions from the windowing system in OS X.  
Until we find a better solution, you may want to run primary/listener VM's with 'nice' (you have to be root):

     %> sudo nice -n -20 chuck [...]
     password: (root/your password)

This makes the audio much more solid...

---

ChucK Compiler + Virtual Machine

SYNAPOSIS

chuck [--(options|commands)] [+-=_] file1 file2 file3 ...

[options] = halt | loop | audio | silent | dump | nodump | bufsize<N> | about
[commands] = add | remove | replace | status | kill | time
[+-=_] = shortcuts for (add, remove, replace, status)


DESCRIPTION

[source ChucK files]:
ChucK can run 1 or more processes in parallel and interactively.  The programmer only needs to specify them all 
on the command line, and they will be compiled and run in the VM.  Each input source file (.ck suffix by 
convention) will be run as a separate 'shred' (user-level ChucK threads) in the VM.  They can 'spork' additional 
shreds and interact with existing shreds.  Thanks to the ChucK timing mechanism, shreds don't necessarily need to 
know about each other in order to be precisely 'shreduled' in time - they only need to keep track of they own 
time, so to speak.

Addtionally, more shreds can be added/removed/replaced manually at run-time, using on-the-fly programming [Wang 
and Cook 2004] - (see below and http://on-the-fly.cs.princeton.edu/).

[options]:

--halt / -h
        (on by default) - tells the vm to halt and exit if there are no more shreds in the VM.

--loop / -l
        tells the ChucK VM to continue executing even if there no shreds currently in the VM.
        This is useful because shreds can be added later on-the-fly.  Furthermore, it is 
        legal to specify this option without any input files.  For example:

        > chuck --loop

        the above will 'infinite time-loop' the VM, waiting for incoming shreds.

--audio / -a
        (on by default) - enable real-time audio output

--silent / -s
        disable real-time audio output - computations in the VM is not changed, except that
        the actual timing is no longer clocked by the real-time audio engine.  Timing 
        manipulations (such as operations on 'now') still function fully.  This is useful
        for synthesizing audio to disk or network.  Also, it is handy for running a non-audio
        program.

--dump / +d
        dump the virtual instructions emitted to stderr, for all the files after this flag
        on the command line, until a 'nodump' is encountered (see below).  For example:

        > chuck foo.ck +d bar.ck

        will dump the virtual ChucK instructions for bar.ck (only), with argument values,
        to stderr.  --dump can be used in conjunction with --nodump to selectively dump files.

--nodump / -d
        (default state) cease the dumping of virtual instructions for files that comes after
        this flag on the command line, until a 'dump' is encountered (see above).  For 
        example:
        
        > chuck +d foo.ck -d bar.ck +d doo.ck

        will dump foo.ck, then doo.ck - but not bar.ck.

        These are useful for debug ChucK itself, and for other entertainment purposes.

--bufsize<N>
        set the internal audio buffer size to <N> sample frames.  larger buffer size
        often reduce audio artifacts due to system/program timing.  smaller buffers reduce
        audio latency.  The default is 512.  If <N> is not a power of 2, the next power
        of 2 larger than <N> is used.  For example:

        > chuck --bufsize950

        sets the buffer size to 1024.

--about / --help
        prints the usage message, with the ChucK URL (where info may be found)


[commands]

These are used for on-the-fly programming.  By default, this requires that a ChucK virtual machine 
be already running on the localhost.  It communicates via sockets to add/remove/replace shreds in
the VM, and to query VM state.  The simplest way to set up a ChucK virtual machine to accept these
commands is by starting an empty VM with --loop:

        > chuck --loop

this will start a VM, looping (and advancing time), waiting for incoming commands.  Successive
invocations of 'chuck' with the appropriate commands will communicate with this listener VM.


--add / +
        add new shreds from source files to the listener VM.
        this process exits after sending the message to the looping VM.

        for example:

          > chuck + foo.ck bar.ck

        integrates foo.ck and bar.ck into the listener VM.  the shred is 
        internally responsible for finding about the timing and other 
        shreds via the timing mechanism and vm interface.

--remove / -
        removes existing shreds from the VM by ID.  how to find out 
        about the id?  (see --status below)  for example:

        > chuck - 2 3 8

        removes shred 2, 3, and 8.

--replace / =
        replace existing shred with a new shred.  for example:

        > chuck = 2 foo.ck

        replaces shred 2 with foo.ck

--status / ^
        queries the status of the VM - output on the listener VM.  for example:

        > chuck ^

        this prints the internal shred start at the listener VM, 
        something like:

        [chuck](VM): status (now == 0h:2m:34s)
            [shred id]: 1  [source]: foo.ck  [sporked]: 21.43s ago
            [shred id]: 2  [source]: bar.ck  [sporked]: 28.37s ago

--time
        prints out value of now in the looping VM.  for example:

        > chuck --time

        [chuck](VM): the value of now:
            now = 403457 (samp)
                = 9.148685 (second)
                = 0.152478 (minute)
                = 0.002541 (hour)
                = 0.000106 (day)
                = 0.000015 (week)

--kill
        semi-gracefully kills the looping VM - removes all shreds first


---
Unit Generators in ChucK

- Unit generators (ugen's) can be connected using the ChucK operator (=>)
  for example:

    adc => dac;

  the above connects the ugen 'adc' (a/d convertor, or audio input) to 'dac'
  (d/a convertor, or audio output). 
    
- they can also unlinked (using =<) and relinked (see examples/unchuck.ck)
- Each unit generator have 0 or more control parameters.
  They can be set also using the ChucK operator (=>, or ->)
  for example:

  // connect sine oscillator to dac
  sinosc osc => dac;
  // set the osc's frequency to 60.0 hz
  60.0 => osc.freq;

  (see examples/osc.ck)

- All ugen's have at least the following two parameters:
  - 'op' (of type 'int')
  - 'gain' (of type 'float')

  'op' determines whether the ugen processes data or not while connected to other ugen's.
      1 - normal processing (on)
      0 - no processing - always output 0
      -1 - pass-through - always returns its input if any

  'gain' is the post gain for the ugen.

- See ---[unit generators]--- for list of current Unit Generaters in ChucK.


--- [ChucK standard API] ---

provide by default with ChucK
(can also import new with ChucK dynamic linking)


***************** namespace: machine *****************

ChucK VM runtime interface

[function]: int add( string path );
- compile and spork a new shred from file at 'path' in to the VM right now
- returns the shred ID

example:

  machine.add( "osc.ck" );

[function]: int spork( string path );
- same as add

[function]: int remove( int id );
- remove shred from the VM by shred ID (returned by add/spork)

[function]: int replace( int id, string path );
- replace shred with new shred from file
- returns shred ID or 0 (if something failed)

[function]: int status( );
- display current status of VM


************** namespace: math ***************

standard math functions

example:

    math.sin( pi/2 ) => stdout;

[function]: float sin( float x );
[function]: float cos( float x );
[function]: float tan( float x );
[function]: float asin( float x );
[function]: float acos( float x );
[function]: float atan( float x );
[function]: float atan2( float x );
[function]: float sinh( float x );
[function]: float cosh( float x );
[function]: float tanh( float x );
[function]: float hypot( float x, float y );
[function]: float pow( float x, float y );
[function]: float sqrt( float x );
[function]: float exp( float x );
[function]: float log( float x );
[function]: float log2( float x );
[function]: float log10( float x );
[function]: float floor( float x );
[function]: float ceil( float x );
[function]: float round( float x );
[function]: float trunc( float x );
[function]: float fmod( float x, float y );
[function]: float remainder( float x, float y );
[function]: float min( float x, float y );
[function]: float max( float x, float y );


**************** namespace: std ****************

[function]: float abs( float value );
floating point absolute avlue

[function]: int rand( );
return between 0 and RAND_MAX

[function]: int rand2( int min, int max )
return integer between [min,max]

[function]: float randf( );
return float between -1.0 and 1.0

[function]: float rand2f( float min, float max )
return float between min and max

[function]: float sgn( float value );
return sign of value (-1, 0, or 1)

[function]: int system( string cmd );
issue system command to the shell (like in C)

example:

    std.system( "ls -l | grep foo" );

[function]: int atoi( string value );
convert string to integer

[function]: float atof( string value );
convert string to float

[function]: string getenv( string key );
get environment variable

[function]: int setenv( string key, string value );
set environment variable

---


--- [unit generators] ---

IMPORTANT: remember all unit generators implicitly have the control 
'gain' and 'op' - not reflected here.


******************** ugen group: xxx **********************

some weird-ish standard ChucK unit generators

----
[ugen]: noise

[ctrl params]: (none)

example:

   noise n => dac;


----
[ugen]: impulse
  pulse generator - can set the value of the current sample
  default for each sample is 0 if not set

[ctrl params]: ( float value ) - set the current sample

example:

   impulse i => dac;

   while( true ) {
      1.0 => i.value;
      100::ms => now;
   }


----
[ugen]: step
  step generator - like impulse, but once a value is set,
  it is held for all following samples, until value is set again.

[ctrl params]: ( float value ) - set the step value

example:

   step s => dac;

   1.0 => float amp;
   // square wave using step
   while( true ) {
       amp => s.value;
       -amp => amp;
       800::samp => now;
   }

----
[ugen]: gain
  gain control
  (NOTE - all unit generators can themselves change their gain)
  (this is way to add N outputs together and scale them)

[ctrl params]: ( float value ) - set the gain

example:

  noise n => gain => dac;
  sinosc s => gain;
  .3 => gain.value;

  while( true ) { 100::ms => now; }


----
[ugen]: halfrect
  half-wave rectifier
  what for?  half-wave rectification

[ctrl params]: (none)


----
[ugen]: fullrect
  full-wave rectifier

[ctrl params]: (none)


---
[ugen]: zerox
  zero-crossing detector
  emits a single pulse at the zero crossing in the direction of the
  zero crossing.

[ctrl params]: (none)


----
[ugen]: sndbuf
  sound buffer

[ctrl param]: ( string path ) - loads a 16-bit mono RAW file
[ctrl parma]: ( int pos ) - set the playback pos - 0 is beginning

----
[ugen]: biquad
  BiQuad filter - two pole/zero zero filter

[ctrl params]: ( float pfreq, float prad, float zfreq, float zrad, int 
norm, float pregain, int eqzs, float b0, float b1, float b2, float a0, 
float a1, float a2 )

[ctrl param]: ( float pfreq ) - pole frequency (hz) - resonance position
[ctrl param]: ( float prad ) - pole radius (must be less than 1)
[ctrl param]: ( float zfreq ) - zero frequency (hz) - notch
[ctrl param]: ( float zrad ) - zero radius
[ctrl param]: ( float eqzs ) - set equal gain zeros
[ctrl param]: ( float norm ) - normalize filter gain
[ctrl param]: ( float b0,b1,b2,a0,a1,a2 ) - filter coefficients

----
[ugen]: sinosc
  sine oscillator

[ctrl param]: ( float freq ) - frequency (hz)
[ctrl param]: ( float sfreq ) - frequency (hz) with phase adjustment
[ctrl param]: ( float phase ) - phase


----
[ugen]: ADSR  (STK import)
  attack decay sustain release

[ctrl params]: ( int keyOn *0x104c62c*, int keyOff *0x104c688* )

[ctrl param]: ( int keyOn ) - turn on ADSR and start
[ctrl param]: ( int keyOff ) - start the release


----
[ugen]: WaveLoop  (STK import)
  interpolating wave loop

[ctrl param]: ( string path ) - load from file
[ctrl param]: ( float freq ) - frequency
[ctrl param]: ( float rate ) - playback rate
[ctrl param]: ( float addPhase ) - add phase
[ctrl param]: ( float addPhaseOffset ) - phase offset


----
[ugen]: JCRev  (STK import)
John Chowning reverb

[ctrl param]: (float mix) dry/wet mix


----
 
more to come...
